name: 'HCP Packer Promote to Channel'
description: 'Promotes a Packer image iteration to an HCP Packer channel using OIDC workload identity federation'
branding:
  icon: 'upload-cloud'
  color: 'purple'
inputs:
  hcp_cred_file:
    description: 'Path to HCP credential file containing workload identity provider configuration'
    required: true
    default: '$HOME/.config/hcp/credentials.json'
  hcp_cli_version:
    description: 'HCP CLI version to install (e.g., "latest" or at least "1.14.2")'
    required: true
    default: 'latest'
  iteration_id:
    description: 'Packer iteration ID to promote to the channel'
    required: true
  channel:
    description: 'HCP Packer channel name to promote to'
    required: true
  bucket_name:
    description: 'HCP Packer bucket name'
    required: true
outputs:
  success:
    description: 'Whether the promotion was successful'
  channel_name:
    description: 'The name of the channel the iteration was promoted to'
  iteration_id:
    description: 'The iteration ID that was promoted'
runs:
  using: 'composite'
  steps:
    - name: Install HCP CLI
      uses: hashicorp/hcp-setup-action@v0.1.0
      with:
        version: ${{ inputs.hcp_cli_version }}

    - name: Promote Image to Channel
      shell: bash
      env:
        HCP_CRED_FILE: ${{ inputs.hcp_cred_file }}
        ITERATION_ID: ${{ inputs.iteration_id }}
        CHANNEL: ${{ inputs.channel }}
        BUCKET_NAME: ${{ inputs.bucket_name }}
      run: |
        # Logging functions
        log_info() {
          echo "::notice::$1"
        }
        
        log_error() {
          echo "::error::$1"
        }
        
        log_success() {
          echo "::notice::$1"
        }

        log_info "Promoting image to $CHANNEL channel..."
        WIP_CONFIG=$(jq -c '.workload.url // empty' "$HCP_CRED_FILE" 2>/dev/null)
        [ -z "$WIP_CONFIG" ] || [ "$WIP_CONFIG" = "null" ] && { log_error "Failed to extract workload identity provider configuration"; exit 1; }
        
        WIP_URL=$(echo "$WIP_CONFIG" | jq -r '.url // empty' 2>/dev/null)
        WIP_HEADERS=$(echo "$WIP_CONFIG" | jq -r '.headers // empty' 2>/dev/null)
        [ -z "$WIP_URL" ] || [ "$WIP_URL" = "null" ] || [ "$WIP_URL" = "" ] && { log_error "Failed to extract URL from workload identity provider configuration"; exit 1; }
        [[ ! "$WIP_URL" =~ ^https?:// ]] && { log_error "Invalid workload identity provider URL format"; exit 1; }

        log_info "Requesting GitHub OIDC token..."
        if [[ "$ACTIONS_ID_TOKEN_REQUEST_URL" == *"?"* ]]; then
          OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://auth.hashicorp.com"
        else
          OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL}?audience=https://auth.hashicorp.com"
        fi
        GITHUB_OIDC_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$OIDC_REQUEST_URL" | jq -r '.value // empty' 2>/dev/null)
        [ -z "$GITHUB_OIDC_TOKEN" ] || [ "$GITHUB_OIDC_TOKEN" = "null" ] && { log_error "Failed to obtain GitHub OIDC token"; exit 1; }

        log_info "Exchanging GitHub OIDC token for HCP access token via workload identity provider..."
        
        # Validate URL format
        if [[ ! "$WIP_URL" =~ ^https:// ]]; then
          log_error "WIP URL must use HTTPS protocol"
          exit 1
        fi
        
        # Extract domain for safe logging (no query params, no paths)
        WIP_DOMAIN=$(echo "$WIP_URL" | sed -E 's|^https?://([^/]+).*|\1|')
        log_info "WIP endpoint domain: $WIP_DOMAIN"
        
        # Count headers for debugging (safe)
        HEADER_COUNT=1  # Content-Type
        if [ -n "$WIP_HEADERS" ] && [ "$WIP_HEADERS" != "null" ]; then
          CUSTOM_HEADER_COUNT=$(echo "$WIP_HEADERS" | jq -r 'to_entries | length' 2>/dev/null || echo "0")
          HEADER_COUNT=$((HEADER_COUNT + CUSTOM_HEADER_COUNT))
        fi
        log_info "Total request headers: $HEADER_COUNT"
        
        CURL_HEADERS=(-H "Content-Type: application/x-www-form-urlencoded")
        [ -n "$WIP_HEADERS" ] && [ "$WIP_HEADERS" != "null" ] && while IFS= read -r header_line; do
          [ -n "$header_line" ] && key=$(echo "$header_line" | cut -d':' -f1 | xargs) && value=$(echo "$header_line" | cut -d':' -f2- | xargs) && [ -n "$key" ] && [ -n "$value" ] && CURL_HEADERS+=(-H "${key}: ${value}")
        done < <(echo "$WIP_HEADERS" | jq -r 'to_entries[] | "\(.key): \(.value)"' 2>/dev/null || echo "")

        # Capture stderr and stdout separately for diagnostic info
        CURL_STDERR=$(mktemp)
        CURL_STDOUT=$(mktemp)
        
        log_info "Making token exchange POST request..."
        # Exit code 5 typically means "Couldn't resolve proxy" - disable proxy to avoid this
        # Capture response body and HTTP code separately
        # -o writes body to file, -w writes format to stdout, -D writes headers to file
        HTTP_HEADERS_FILE=$(mktemp)
        HTTP_CODE_FILE=$(mktemp)
        curl -X POST "$WIP_URL" "${CURL_HEADERS[@]}" \
          -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
          -d "subject_token=$GITHUB_OIDC_TOKEN" \
          -d "subject_token_type=urn:ietf:params:oauth:token-type:jwt" \
          -d "requested_token_type=urn:ietf:params:oauth:token-type:access_token" \
          --max-time 30 \
          --connect-timeout 10 \
          --noproxy "*" \
          -o "$CURL_STDOUT" \
          -w "%{http_code}" \
          -D "$HTTP_HEADERS_FILE" \
          -s \
          > "$HTTP_CODE_FILE" \
          2>"$CURL_STDERR"
        CURL_EXIT_CODE=$?
        TOKEN_RESPONSE=$(cat "$CURL_STDOUT" 2>/dev/null || echo "")
        CURL_ERROR=$(cat "$CURL_STDERR" 2>/dev/null || echo "")
        HTTP_CODE_RAW=$(cat "$HTTP_CODE_FILE" 2>/dev/null | tr -d '\n\r' || echo "")
        HTTP_HEADERS=$(cat "$HTTP_HEADERS_FILE" 2>/dev/null || echo "")
        rm -f "$CURL_STDERR" "$CURL_STDOUT" "$HTTP_CODE_FILE" "$HTTP_HEADERS_FILE"
        
        # Extract HTTP code - it should be a 3-digit number
        # First try to get it from the curl -w output (should be just the number)
        HTTP_CODE=""
        # Extract only numeric HTTP code from the raw output, removing any JSON or other text
        HTTP_CODE=$(echo "$HTTP_CODE_RAW" | grep -oE '[0-9]{3}' | head -n 1 || echo "")
        # If that failed, try to extract from HTTP headers as fallback
        if [ -z "$HTTP_CODE" ] && [ -n "$HTTP_HEADERS" ]; then
          HTTP_CODE=$(echo "$HTTP_HEADERS" | grep -iE '^HTTP/' | head -n 1 | grep -oE '[0-9]{3}' | head -n 1 || echo "")
        fi
        
        if [ $CURL_EXIT_CODE != 0 ]; then
          log_error "Token exchange request failed with curl exit code $CURL_EXIT_CODE"
          if [ -n "$CURL_ERROR" ]; then
            # Log curl error messages (usually safe - they're about DNS, SSL, etc., not tokens)
            SANITIZED_ERROR=$(echo "$CURL_ERROR" | head -c 500 | tr -d '\n\r' | sed 's/[^[:print:]]/ /g')
            log_error "Curl error details: $SANITIZED_ERROR"
          else
            log_error "No curl error message captured (stderr was empty)"
          fi
          if [ -n "$HTTP_CODE" ] && [[ "$HTTP_CODE" =~ ^[0-9]{3}$ ]]; then
            log_error "Response HTTP code: $HTTP_CODE"
          else
            log_error "No valid HTTP code captured. Raw output: '${HTTP_CODE_RAW}'"
          fi
          log_error "Failed to reach WIP endpoint at domain: $WIP_DOMAIN"
          log_error "URL format validated: HTTPS protocol confirmed"
          log_error "Headers configured: $HEADER_COUNT headers total"
          exit 1
        fi
        
        # Validate HTTP code is numeric and exists
        if [ -z "$HTTP_CODE" ]; then
          log_error "Failed to extract HTTP code from response"
          log_error "Raw HTTP code output: '${HTTP_CODE_RAW}' (first 100 chars)"
          log_error "Response body length: ${#TOKEN_RESPONSE} chars"
          log_error "Response body preview: $(echo "$TOKEN_RESPONSE" | head -c 200)"
          exit 1
        fi
        
        # Validate HTTP code is numeric (must be exactly 3 digits)
        if ! [[ "$HTTP_CODE" =~ ^[0-9]{3}$ ]]; then
          log_error "HTTP code is not a valid 3-digit number: '${HTTP_CODE}'"
          log_error "Raw HTTP code output: '${HTTP_CODE_RAW}'"
          log_error "Response body length: ${#TOKEN_RESPONSE} chars"
          log_error "Response body preview: $(echo "$TOKEN_RESPONSE" | head -c 200)"
          exit 1
        fi
        
        # Response body is already separated (TOKEN_RESPONSE contains just the body)
        RESPONSE_BODY="$TOKEN_RESPONSE"
        
        # Validate HTTP code is success (200-299) - use numeric comparison only after validation
        HTTP_CODE_NUM=$((HTTP_CODE + 0))  # Convert to integer for safe comparison
        if [ "$HTTP_CODE_NUM" -lt 200 ] || [ "$HTTP_CODE_NUM" -ge 300 ]; then
          log_error "Token exchange failed with HTTP $HTTP_CODE"
          log_error "Response body (first 200 chars): $(echo "$RESPONSE_BODY" | head -c 200)"
          exit 1
        fi

        # Validate response is JSON
        if ! echo "$RESPONSE_BODY" | jq empty 2>/dev/null; then
          log_error "Token exchange response is not valid JSON"
          log_error "Response body (first 500 chars): $(echo "$RESPONSE_BODY" | head -c 500)"
          exit 1
        fi
        
        RESPONSE_KEYS=$(echo "$RESPONSE_BODY" | jq -r 'keys | join(", ")' 2>/dev/null || echo "not JSON")
        log_info "Response contains keys: $RESPONSE_KEYS"
        
        # Try multiple token field formats - Azure WIP might return {"value":"token"} format
        # Also handle nested structures like {"value":{"access_token":"token"}}
        HCP_ACCESS_TOKEN=$(echo "$RESPONSE_BODY" | jq -r '
          .access_token // 
          .token // 
          .accessToken // 
          .value // 
          (if .value | type == "object" then .value.access_token // .value.token else empty end) //
          empty' 2>/dev/null)
        
        if [ -z "$HCP_ACCESS_TOKEN" ] || [ "$HCP_ACCESS_TOKEN" = "null" ]; then
          log_error "Failed to extract access_token from token exchange response"
          log_error "HTTP Code: $HTTP_CODE"
          log_error "Response contains keys: $RESPONSE_KEYS"
          log_error "Response body structure: $(echo "$RESPONSE_BODY" | jq -c '.' 2>/dev/null | head -c 500)"
          exit 1
        fi
        
        # Trim whitespace and newlines from token
        HCP_ACCESS_TOKEN=$(echo "$HCP_ACCESS_TOKEN" | tr -d '\n\r\t ' | xargs)
        [ -z "$HCP_ACCESS_TOKEN" ] && { log_error "Access token is empty after trimming"; exit 1; }
        log_info "Successfully obtained HCP access token (length: ${#HCP_ACCESS_TOKEN} chars)"

        log_info "Authenticating HCP CLI..."
        hcp auth login --cred-file="$HCP_CRED_FILE" || { log_error "Failed to authenticate HCP CLI"; exit 1; }
        log_success "HCP CLI authenticated successfully."

        # Try to get access token from HCP CLI (this token should have proper permissions)
        log_info "Obtaining access token from HCP CLI..."
        HCP_CLI_TOKEN=$(hcp auth print-access-token 2>/dev/null || echo "")
        if [ -n "$HCP_CLI_TOKEN" ] && [ "$HCP_CLI_TOKEN" != "null" ]; then
          HCP_CLI_TOKEN=$(echo "$HCP_CLI_TOKEN" | tr -d '\n\r\t ' | xargs)
          log_info "Using HCP CLI access token for API calls"
          API_ACCESS_TOKEN="$HCP_CLI_TOKEN"
        else
          log_info "HCP CLI token not available, using workload identity token"
          API_ACCESS_TOKEN="$HCP_ACCESS_TOKEN"
        fi

        log_info "Fetching organization ID..."
        ORG_JSON_OUTPUT=$(hcp organizations list --format=json 2>&1) || { log_error "Failed to run 'hcp organizations list'"; exit 1; }
        HCP_ORG_ID=$(echo "$ORG_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
        [ -z "$HCP_ORG_ID" ] || [ "$HCP_ORG_ID" = "null" ] && { log_error "Failed to extract organization ID"; exit 1; }
        log_info "Organization ID: $HCP_ORG_ID"

        log_info "Fetching project ID..."
        PROJECT_JSON_OUTPUT=$(hcp projects list --format=json 2>&1) || { log_error "Failed to run 'hcp projects list'"; exit 1; }
        HCP_PROJECT_ID=$(echo "$PROJECT_JSON_OUTPUT" | jq -r '.[0].id // empty' 2>/dev/null)
        [ -z "$HCP_PROJECT_ID" ] || [ "$HCP_PROJECT_ID" = "null" ] && { log_error "Failed to extract project ID"; exit 1; }
        log_info "Project ID: $HCP_PROJECT_ID"

        log_info "Promoting iteration $ITERATION_ID to channel $CHANNEL..."
        
        # Prepare the API endpoint
        API_URL="https://api.cloud.hashicorp.com/packer/2021-04-30/organizations/${HCP_ORG_ID}/projects/${HCP_PROJECT_ID}/images/${BUCKET_NAME}/channels/${CHANNEL}"
        log_info "API URL: ${API_URL}"
        
        # Make the PATCH request with better error handling
        CHANNEL_RESPONSE_FILE=$(mktemp)
        CHANNEL_HTTP_CODE_FILE=$(mktemp)
        CHANNEL_ERROR_FILE=$(mktemp)
        
        curl -X PATCH \
          "$API_URL" \
          --header "Authorization: Bearer ${API_ACCESS_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "{\"iteration_id\": \"$ITERATION_ID\"}" \
          -w "\n%{http_code}" \
          -s \
          -o "$CHANNEL_RESPONSE_FILE" \
          -D "$CHANNEL_ERROR_FILE" \
          2>/dev/null > "$CHANNEL_HTTP_CODE_FILE"
        
        CURL_EXIT_CODE=$?
        CHANNEL_RESPONSE=$(cat "$CHANNEL_RESPONSE_FILE" 2>/dev/null || echo "")
        HTTP_CODE=$(cat "$CHANNEL_HTTP_CODE_FILE" 2>/dev/null | tail -n 1 | tr -d '\n\r' || echo "")
        HTTP_HEADERS=$(cat "$CHANNEL_ERROR_FILE" 2>/dev/null || echo "")
        
        rm -f "$CHANNEL_RESPONSE_FILE" "$CHANNEL_HTTP_CODE_FILE" "$CHANNEL_ERROR_FILE"
        
        # Extract HTTP code if it's mixed with response
        if [ -z "$HTTP_CODE" ] || ! [[ "$HTTP_CODE" =~ ^[0-9]{3}$ ]]; then
          # Try to extract from the response if it's at the end
          HTTP_CODE=$(echo "$CHANNEL_RESPONSE" | grep -oE '[0-9]{3}$' | tail -n 1 || echo "")
          CHANNEL_RESPONSE=$(echo "$CHANNEL_RESPONSE" | sed '$d' || echo "$CHANNEL_RESPONSE")
        fi
        
        if [ "$CURL_EXIT_CODE" != 0 ]; then
          log_error "Failed to make API request to promote iteration. Curl exit code: $CURL_EXIT_CODE"
          exit 1
        fi
        
        if [ -z "$HTTP_CODE" ] || ! [[ "$HTTP_CODE" =~ ^[0-9]{3}$ ]]; then
          log_error "Failed to extract HTTP code from channel promotion response"
          log_error "Response: $(echo "$CHANNEL_RESPONSE" | head -c 500)"
          exit 1
        fi
        
        if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "204" ]; then
          log_error "Failed to assign iteration to channel. HTTP $HTTP_CODE"
          if [ -n "$CHANNEL_RESPONSE" ]; then
            log_error "Response body: $(echo "$CHANNEL_RESPONSE" | head -c 1000)"
          fi
          if [ -n "$HTTP_HEADERS" ]; then
            log_error "Response headers: $(echo "$HTTP_HEADERS" | head -c 500)"
          fi
          log_error "This might indicate:"
          log_error "  1. The access token doesn't have sufficient permissions"
          log_error "  2. The service principal needs 'contributor' role for Packer operations"
          log_error "  3. The iteration ID or channel name is incorrect"
          exit 1
        fi
        
        log_success "Image promoted to $CHANNEL channel."
        
        # Set outputs
        echo "success=true" >> $GITHUB_OUTPUT
        echo "channel_name=$CHANNEL" >> $GITHUB_OUTPUT
        echo "iteration_id=$ITERATION_ID" >> $GITHUB_OUTPUT

